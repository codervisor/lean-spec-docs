---
id: 'ai-agent-memory'
title: 'AI 代理记忆'
sidebar_position: 4
---
# AI 代理记忆

> "规范作为 AI 代理的持久语义记忆。"

LeanSpec 规范作为 AI 代理的**持久记忆层**——提供跨会话持久的长期知识存储，并实现有效的人机协作。

## 记忆问题

AI 代理面临一个根本挑战：**工作记忆是短暂的**。

- 每个聊天会话都从头开始（没有先前对话的记忆）
- 上下文窗口有限（即使有 1M+ 令牌）
- 重要的决策和理由在会话之间丢失
- 代理重复问题或做出与过去工作不一致的决策

**传统解决方案**：对文档的 RAG（检索增强生成）

**LeanSpec 解决方案**：规范作为**语义记忆** - 代理可以可靠访问的结构化、持久知识

## 规范作为语义记忆

借鉴认知科学研究（[CoALA 论文](https://arxiv.org/pdf/2309.02427)），AI 代理受益于两种类型的记忆：

### 工作记忆（短暂）
- **什么**：当前对话上下文，活动任务信息
- **生命周期**：单个会话或任务
- **存储**：聊天历史，上下文窗口
- **大小**：受上下文窗口限制（100k-1M 令牌）

### 语义记忆（持久）
- **什么**：长期知识、事实、决策、理由
- **生命周期**：跨会话和任务持久
- **存储**：LeanSpec 规范 + MCP 检索
- **大小**：无限制（外部存储）

**LeanSpec 规范 = AI 代理的语义记忆**

## 如何工作

### 记忆存储（编写规范）

在与 AI 代理一起工作时，规范捕获：

1. **做出的决策**：选择了什么以及为什么
2. **评估的权衡**：考虑的选项，分析的优缺点
3. **发现的约束**：技术限制，业务需求
4. **澄清的意图**：工作背后的"为什么"
5. **定义的成功标准**：如何知道它完成了

**示例**：
```markdown
# 功能：API 速率限制

## 问题
API 被大量请求击中，40% 的请求来自 2% 的用户。

## 解决方案
实现令牌桶速率限制（每个 API 密钥 100 req/min）。

## 为什么选择令牌桶？
- 允许突发（比固定窗口更好的用户体验）
- 久经考验（AWS、Stripe 使用）
- 使用 Redis 实现简单

## 权衡
- 增加的复杂性（Redis 依赖）
- 潜在的用户体验摩擦（用户达到限制）
- 值得：保护 98% 的用户免受 2% 滥用

## 成功标准
- [ ] 95% 的 API 请求成功（从 60% 提高）
- [ ] 响应时间 p95 < 200ms（曾是 2-3 秒）
- [ ] 零误报（合法用户被速率限制）
```

这成为代理可以在未来会话中引用的**语义记忆**。

### 记忆检索（AI 访问规范）

AI 代理通过以下方式访问规范记忆：

1. **MCP 服务器集成**：LeanSpec MCP 服务器提供规范搜索/检索
2. **语义搜索**：代理按主题、状态、标签查询规范
3. **选择性加载**：仅将相关规范加载到工作记忆中
4. **交叉引用**：跟随 `depends_on` 和 `related` 链接

**工作流程**：
```markdown
人类："为什么我们选择 PostgreSQL 而不是 MongoDB？"

AI 代理：
1. 查询 LeanSpec MCP：search_specs("database decision")
2. 检索规范 023：数据库选择
3. 从语义记忆中读取决策理由
4. 响应："根据规范 023，选择 PostgreSQL 是因为..."
```

### 记忆作为上下文桥梁

规范桥接以下之间的差距：
- **人类记忆**（为什么我们这样做，什么重要）
- **AI 工作记忆**（当前任务，活动上下文）
- **代码库现实**（实际实现的内容）

```mermaid
flowchart LR
    Human[人类意图] -->|编写| Spec[LeanSpec 规范]
    Spec -->|MCP 检索| AI[AI 代理]
    AI -->|实现| Code[代码库]
    Code -->|验证| Spec
    
    style Spec fill:#16a34a,stroke:#15803d,color:#fff
    style AI fill:#3b82f6,stroke:#2563eb,color:#fff
```

## LeanSpec 中的记忆类型

### 1. 程序记忆（如何）
- **什么**：标准模式、模板、工作流程
- **存储**：模板，AGENTS.md 指令
- **示例**："始终在提交前验证前置元数据"

### 2. 语义记忆（什么/为什么）
- **什么**：事实、决策、理由、约束
- **存储**：LeanSpec 规范（README、DESIGN 等）
- **示例**："为无状态认证选择了 JWT 令牌（见规范 042）"

### 3. 情节记忆（何时/上下文）
- **什么**：历史事件，何时发生了什么
- **存储**：Git 历史，规范转换，时间戳
- **示例**："API 重新设计（规范 038）发生在认证重构（规范 037）之后"

**LeanSpec 主要提供语义记忆** - 持久知识层。

## 规范作为记忆的好处

### 对于 AI 代理
✅ **跨会话的持久上下文**  
✅ **可靠地检索**过去的决策  
✅ **与项目历史一致的行为**  
✅ **减少幻觉**（事实来自规范，而不是猜测）  
✅ **可扩展的知识**（不受上下文窗口限制）

### 对于人类
✅ **与 AI 代理的共同理解**  
✅ **捕获和可访问的机构知识**  
✅ **简化入职**（新人类和新 AI 会话）  
✅ **决策审计跟踪**（为什么事情是这样的）  
✅ **上下文切换**（离开项目几个月后返回）

### 对于团队
✅ **团队协调**（每个人都阅读相同的记忆）  
✅ **异步协作**（代理从共享记忆工作）  
✅ **知识连续性**（不依赖于个人）  
✅ **减少会议**（决策被记录，而不是反复讨论）

## 记忆维护

像人类记忆一样，规范记忆需要维护：

### 主动回忆（保持最新）
- 随着理解的发展更新规范
- 清楚标记被取代的决策
- 归档完成的工作（压缩为摘要）

### 巩固（防止膨胀）
- 应用[上下文工程](/zh-Hans/docs/guide/context-engineering)策略
- 分区（Partition）大规范（>400 行）
- 精简（Compact）冗余内容
- 压缩（Compress）历史阶段

### 检索练习（验证访问）
- 测试 MCP 搜索检索相关规范
- 验证交叉引用（depends_on、related）
- 检查关键决策是否可查找

## 最佳实践

**做**：
- ✅ 捕获"为什么"和权衡（稳定的语义记忆）
- ✅ 随着现实改变更新规范（保持记忆准确）
- ✅ 在询问人类之前使用 MCP 搜索检索
- ✅ 交叉引用相关规范（记忆关联）
- ✅ 归档完成的工作（释放工作记忆）

**不要做**：
- ❌ 记录一切（记忆过载）
- ❌ 让规范偏离现实（损坏的记忆）
- ❌ 跨规范重复信息（记忆膨胀）
- ❌ 留下冲突信息（上下文冲突）

## 底线

**LeanSpec 将规范从静态文档转变为 AI 代理的活跃语义记忆。**

- **工作记忆**（聊天历史）是短暂且有限的
- **语义记忆**（规范）是持久且可扩展的
- **MCP 集成**实现可靠的记忆检索
- **上下文工程**保持记忆可管理

当 AI 代理可以可靠地访问过去的决策、理解理由并基于先前的工作构建时，它们成为**真正的协作者**，而不是会话绑定的助手。

---

**相关**：了解[上下文工程](/zh-Hans/docs/guide/context-engineering)以管理记忆大小，或探索 [MCP 集成](/zh-Hans/docs/reference/mcp-server)以了解记忆检索的技术实现。
