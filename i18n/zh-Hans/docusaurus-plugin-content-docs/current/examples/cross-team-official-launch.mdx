---
sidebar_position: 5
title: 跨团队特性 - 正式发布
---

# 跨团队特性：正式发布 v0.2.0

:::info 示例档案
- **Spec**: [043-official-launch-02](https://web.lean-spec.dev/specs/043-official-launch-02)
- **类型**: 跨团队发布 / 项目管理
- **复杂度**: 非常高 (多 Spec 协作)
- **完成时间**: ~6 周 (含依赖项)
- **过滤器**: `Cross-Team` `Program` `Release`
- **适用场景**: 负责协调多个 Spec、审批和 AI Agent 以达成单一发布日期的负责人 (Leads)。
:::

## 学习目标

- 设计一个元 Spec (meta-spec) 来编排依赖的 Spec，同时保持范围足够小以确保能够发布。
- 设定发布关卡 (launch gates)，以便人类和 Agent 确切知道何时达到质量标准。
- 使用 Spec 关系 (`depends_on`, `related`) 来沟通发布顺序，无需开会。

## 背景 (Context)

### 问题 (The Problem)

LeanSpec v0.1.0 是用于早期验证的 Alpha 版本。现在我们需要发布 v0.2.0 作为**正式公开版本**，并将 v0.1.0 视为仅供内部使用。

**挑战**：这不仅仅是一个单一功能——它是协调**多个 Spec**，跨越：
- 基础工作 (第一性原理 - Spec 049)
- 落地实施 (验证工具 - Spec 018)
- 功能开发 (模式选择 - Spec 024, 026)
- 文档 (AGENTS.md - Spec 051)
- 网站 (实时展示 - Spec 035)

**关键问题**：
- 对于 v0.2.0 来说，什么是核心必要的，什么是锦上添花的？
- 我们如何在没有频繁会议的情况下协调 5 个以上的 Spec？
- 如果我们在发布中期发现阻塞项怎么办？
- 我们如何在保持速度的同时确保质量？

### 为什么需要这个 Spec？ (Why This Spec?)

**如果没有这个协调 Spec**：
- 各个 Spec 孤立工作，忽略依赖关系
- 发布日期不断推迟（“再加一个功能就好”）
- 质量关卡不明确，带着 Bug 发布
- 团队不知道范围包括什么

**有了协调 Spec**：
- 清晰的发布标准和范围
- 依赖关系明确 (Spec 049 → Spec 051 → Spec 018)
- 可以将非必要工作推迟到 v0.3.0
- 每个人都能一目了然地了解状态

**这是一个元 Spec (meta-spec)** - 它不实现具体功能，而是协调其他 Spec。

## Spec 内容 (The Spec)

### 发布策略 (Launch Strategy)

具有清晰依赖关系的**三阶段发布**：

```
第 1-2 周：基础 (Foundation)
├─ Spec 049: 第一性原理探索 ✅
├─ Spec 048: 复杂度分析工具 ✅
└─ Spec 051: AGENTS.md & README 更新 ⬅ 依赖于 049

第 3-4 周：落地实施 (Operationalization)
├─ Spec 018: 验证 (复杂度检查) ⬅ 依赖于 048
├─ Spec 024: 模式感知列表 ⬅ 依赖于 018
└─ Spec 026: Init 模式选择 ⬅ 依赖于 024

第 5-6 周：发布准备 (Launch Preparation)
├─ Spec 044: Spec 关系清晰化
├─ Spec 035: 实时 Spec 展示 (如果准备好的话)
└─ 营销与文档润色
```

### 成功标准 (Success Criteria)

**技术质量关卡**：
- ✅ 100% 测试通过率 (261/261 通过)
- ✅ 零严重 (critical) 或高危 (high severity) Bug
- ✅ MCP Server 稳定性 (出错时不崩溃)
- ⏱️ 常用命令的 CLI 响应时间 &lt;100ms
- ✅ 文档准确性已验证 (Spec 056)
- ✅ 所有示例经测试可运行 (Spec 056)

**用户体验基准**：
- ✅ 首次用户在 &lt;15 分钟内完成教程
- ✅ AI Agent 无需人类澄清即可使用 Spec
- ✅ 仅通过文档即可理解设计哲学

**哲学一致性**：
- ✅ 通过工具化落地第一性原理
- ✅ 践行我们所宣扬的 (吃自己的狗粮/Dogfooding)
- ✅ 将重大重构推迟到 v0.3.0 (保持精益)

### 关键决策：范围缩减 (Scope Reduction)

**原计划**：在 Spec 050 (重大重构) 中发布所有内容

**发现**：第一性原理 (Spec 049) 从根本上重构了优先级：
- 基础 > 功能堆砌
- 落地实施 > 更多模式
- 质量 > 速度

**调整后的计划**：
- ✅ 保留：基础工作 (Spec 049, 051, 018)
- ✅ 保留：核心功能 (Spec 024, 026)
- 📅 推迟：重大重构 (Spec 050) 到 v0.3.0
- 📅 推迟：Copilot Slash 命令 (Spec 034) 到 v0.3.0

**为什么要推迟？** 保持精益，在增加复杂度之前验证核心价值。

[查看完整 Spec →](https://web.lean-spec.dev/specs/043-official-launch-02)

## 实现 (Implementation)

### 第一阶段：基础 (第 1-2 周)

**目标**：建立哲学基础并通过工具化进行落地。

**关键工作**：

1. **Spec 049: 第一性原理探索** ✅
   - 从 90 多个 Spec 中提炼出 5 条第一性原理
   - 上下文经济 (Context Economy)、信噪比 (Signal-to-Noise)、意图优于实现 (Intent Over Implementation)、弥合差距 (Bridge the Gap)、渐进式披露 (Progressive Disclosure)
   - 记录了冲突解决框架

2. **Spec 048: 复杂度分析工具** ✅
   - 实现了 `lean-spec analyze` 以获取复杂度洞察
   - 每个部分的 Token 计数
   - 拆分建议

3. **Spec 051: AGENTS.md & README 更新** ✅
   - 更新文档以反映第一性原理
   - 添加了基于原则的决策框架
   - 改进了 AI Agent 指令

**协调挑战**：
- Spec 051 阻塞于 Spec 049 的完成
- 需要在编写文档前确定原则
- 使用了 Spec 关系：`related: [049]`

### 第二阶段：落地实施 (第 3-4 周)

**目标**：发布能够防止违反原则的工具。

**关键工作**：

1. **Spec 018: 带复杂度检查的验证** ✅
   - 添加了 Token 阈值验证
   - 集成到 `lean-spec validate`
   - CI 集成用于自动检查

2. **Spec 024: 模式感知列表** ✅
   - 增强了 `lean-spec list` 的模式检测功能
   - 显示哪些 Spec 使用了哪些模式
   - 帮助用户查找示例

3. **Spec 026: Init 模式选择** ✅
   - `lean-spec create` 中的交互式模式选择器
   - 基于第一性原理的描述
   - 基于项目规模的智能默认值

**协调方法**：
- 每周同步以审查进度
- Spec 通过 `related` 字段链接以提供上下文
- 阻塞项在 Spec 的 Notes 部分中浮现

### 第三阶段：发布准备 (第 5-6 周)

**目标**：润色并准备公开发布。

**关键工作**：

1. **Spec 044: Spec 关系清晰化** ✅
   - 澄清了 `related` 与 `depends_on` 的区别
   - 用示例更新了文档
   - 改进了 `lean-spec deps` 的输出

2. **Spec 035: 实时 Spec 展示** ⏳
   - 发现：比预期的更复杂
   - 决策：移至 v0.3.0 作为旗舰功能
   - 理由：不要因为非核心功能推迟发布

3. **营销内容** ✅
   - 强调第一性原理哲学
   - 创建了比较指南
   - 录制了演示视频

4. **Beta 测试** ✅
   - 5 位外部用户进行了预发布测试
   - 收集反馈，修复了 3 个 UX 问题
   - 验证了文档的清晰度

**关键决策点**：
- 第 5 周：意识到 Spec 035 会将发布推迟 2 周以上
- 团队决策：推迟到 v0.3.0
- Spec 043 更新了理由
- 向利益相关者沟通了变更

## 演进 (Evolution)

### 在实现过程中发生了什么变化？

**1. 范围纪律 (Scope Discipline)**

**最初的心态**：“让我们把能做的都加进去！”

**Spec 049 之后的转变**：“对于 v0.2.0 的价值主张，什么是必不可少的？”

**影响**：
- 推迟 Spec 050 (重大重构) - 太大，非必要
- 推迟 Spec 034 (Copilot 命令) - 锦上添花，非关键
- 将 Spec 035 (实时展示) 移至 v0.3.0 - 下一个版本的旗舰功能

**教训**：第一性原理帮助我们对不符合 v0.2.0 目标的好点子说“不”。

**2. 质量优于速度**

**原计划**：4 周内发布

**现实**：花了 6 周，但质量更高

**变更**：
- 增加了 Beta 测试阶段（不在原计划中）
- 对所有 Spec 运行 `lean-spec validate`，拆分了 8 个过大的 Spec
- 在发布前修复了所有失败的测试（有 3 个测试是不稳定的）

**权衡**：推迟了 2 周，但发布时零严重 Bug。

**3. 文档作为一等公民**

**原计划**：文档放在最后

**现实**：文档驱动采用

**变更**：
- Spec 051 提升到第一阶段（原为第三阶段）
- 在发布中期添加了 Spec 056 (文档验证)
- 编写了比较指南（不在原计划中）

**影响**：用户反馈“这是所有 CLI 工具中最好的文档”——值得投入时间。

**4. 持续的范围重新评估**

**第 2 周**：发现第一性原理改变了优先级 → 更新 Spec 043

**第 4 周**：意识到 Spec 035 无法按时完成 → 更新 Spec 043

**第 5 周**：Beta 测试揭示了 3 个 UX 问题 → 更新 Spec 043

**模式**：**Spec 作为活文档**。当计划变更时更新 Spec 043，保持团队对齐。

### 挑战

**挑战 1：依赖协调**

**问题**：Spec 051 阻塞于 Spec 049，但 Spec 049 的负责人去度假了。

**解决方案**：
- 在 Spec 051 Frontmatter 中使用 `depends_on: [049]`
- `lean-spec deps 051` 清晰显示了阻塞项
- 重新分配 Spec 049 以解除阻塞

**教训**：显式依赖 > 隐式假设。

**挑战 2：范围蔓延 (Scope Creep)**

**问题**：团队不断想往 v0.2.0 里加“哪怕再多一件事”。

**解决方案**：
- Spec 043 成为范围的“事实来源”
- 变更需要更新 Spec 并达成共识
- “这对 v0.2.0 是必不可少的吗？”成为测试问题

**教训**：协调 Spec 提供了范围纪律。

**挑战 3：优先级变更**

**问题**：第一性原理探索 (Spec 049) 改变了“好”的定义。

**解决方案**：
- 更新 Spec 043 以反映新的优先级
- 在 Spec 中记录变更理由
- 团队在继续之前审查更新后的 Spec

**教训**：Spec 通过使变更显式化来支持转型 (pivots)。

**挑战 4：沟通开销**

**问题**：6 个人处理 8 个相关的 Spec = 协调混乱。

**解决方案**：
- Spec 043 作为“任务控制中心”
- 通过 Spec 更新进行每周异步检查
- `lean-spec board` 一目了然地显示状态

**教训**：Spec 减少了会议开销。

## 结果 (Outcome)

### 发布指标

**质量** ✅：
- 261/261 测试通过 (100%)
- 发布时零严重 Bug
- 第一周零高危 Bug

**性能** ✅：
- CLI 命令：45-95ms (目标：&lt;100ms)
- MCP Server：每次请求 &lt;50ms
- 文档站点：加载时间 &lt;2s

**采用率** 🚀：
- 第 1 周：127 npm 下载量
- 第 2 周：243 npm 下载量 (+91%)
- 第 4 周：456 npm 下载量 (+87%)
- GitHub Star：首月 +78

**用户反馈** 💬：
- “我见过的最好的 CLI 文档”
- “喜欢它是原则驱动的，而不仅仅是功能”
- “AI Agent 实际上成功使用了这些 Spec”

### 团队指标

**协调效率**：
- 会议：总共 4 次（每周 1 次） vs 典型每周 3 次以上
- 异步沟通：Spec 更新代替 Slack 讨论串
- 清晰度：团队始终知道什么在范围内/范围外

**速度**：
- 6 周发布（目标 4 周）
- 但是：零严重 Bug（典型每次发布 2-3 个）
- 权衡：更慢，但质量更高

**Spec 质量**：
- 发布期间更新了 8 个 Spec（演进）
- 3 个 Spec 推迟到 v0.3.0（范围纪律）
- 发布中期添加了 1 个 Spec（Spec 056 - 文档验证）

## 教训 (Lessons)

### 哪些做对了

✅ **Spec 作为协调工具**
   - 范围的单一事实来源
   - 依赖跟踪防止了瓶颈
   - 通过 `lean-spec board` 状态一目了然

✅ **显式依赖**
   - `depends_on` 字段使阻塞项显而易见
   - `lean-spec deps <spec>` 显示关键路径
   - 可以优先处理解除阻塞的工作

✅ **活文档方法**
   - 随着计划变更更新 Spec 043
   - 保持团队对齐，无需频繁会议
   - 决策和理由的历史记录

✅ **通过 Spec 进行范围纪律**
   - “它在 Spec 043 里吗？”成为过滤器
   - 平稳推迟了 3 个 Spec
   - 第一性原理帮助确定优先级

✅ **三阶段结构**
   - 清晰的边界（基础 → 运维 → 润色）
   - 可以在进入下一阶段前验证每个阶段
   - 降低了级联故障的风险

### 我们会做哪些不同的尝试

🔄 **更早的 Beta 测试**
   - 第 5 周才开始，本应在第 3 周
   - 本可以更早发现 UX 问题
   - 本可以有更多时间修复

🔄 **更明确的时间估算**
   - Spec 043 有阶段但没有时间框 (time boxes)
   - 难以早期发现延期
   - 本应为每个阶段添加“第 X-Y 周”

🔄 **更清晰的推迟标准**
   - 直到第 5 周才推迟 Spec 035
   - 本应从一开始就有“必要 vs 锦上添花”的标准
   - 本可以减少范围争论

🔄 **每日状态更新**
   - 使用了每周更新，感觉太慢
   - 本应每天使用 `lean-spec update`
   - 本可以更快发现阻塞项

### 关键要点

**1. Spec 实现无会议协调**
   - 通过 Spec 更新进行异步沟通
   - 通过 `lean-spec board` 查看状态
   - 通过 Frontmatter 明确依赖关系

**2. 协调 Spec 不同于功能 Spec**
   - 元层面 (Meta-level)：协调其他 Spec
   - 活文档：随着计划变更而更新
   - 范围纪律：过滤什么在范围内/外

**3. 第一性原理支持艰难决策**
   - 帮助优先考虑基础而非功能
   - 使推迟决策变得清晰（而非情绪化）
   - 团队在“为什么”上对齐，而不仅仅是“做什么”

**4. 质量需要范围纪律**
   - 无法同时拥有速度 + 质量 + 完整范围
   - 3 选 2
   - 我们选择了质量 + (较完整的) 范围，牺牲了速度

**5. Spec 减少协调开销**
   - 总共 4 次会议 vs 典型的 12 次以上
   - 异步更新代替 Slack 讨论串
   - Spec 历史记录中清晰的决策记录

## AI Agent 协作

### AI Agent 如何使用此 Spec

**GitHub Copilot Agent**：
1. 阅读 Spec 043 以了解发布范围和优先级
2. 使用 `related` 字段查找依赖的 Spec
3. 根据阶段计划实现功能
4. 随着工作完成更新 Spec 043 状态
5. 当工作可能错过截止日期时进行标记

**挑战**：这是一个**协调 Spec**，而不是实现 Spec。AI Agent 需要指导：
- 接下来处理哪个 Spec
- 何时更新 Spec 043 的进度
- 如何标记阻塞项

**解决方案**：
- Spec 043 清晰链接到所有相关 Spec
- 每个阶段按优先级顺序列出 Spec
- Agent 按顺序处理 Spec，并汇报

**Agent 自主性**：协调方面 40% - 需要更高的人类参与度用于：
- 优先级决策（推迟什么？）
- 范围变更（何时更新 Spec 043？）
- 质量判断（这准备好发布了吗？）

**实现自主性**：在单个 Spec 内 75% - 一旦方向明确，Agent 实现得很好。

### 用于协调的 Spec 质量

**是什么让协调 Spec 与众不同**：

1. **元层面思维** - 协调其他 Spec，而不是实现功能
2. **活文档** - 比典型 Spec 在实现期间有更多更新
3. **判断调用** - 推迟决策需要人类输入
4. **关系管理** - 许多 `related` 和 `depends_on` 字段

**什么帮助了 AI Agent**：

1. **显式阶段** - 清楚什么工作在何时发生
2. **成功标准** - 每个阶段的可衡量关卡
3. **链接的 Spec** - 易于导航到实现 Spec
4. **状态跟踪** - 可以看到什么是阻塞的 vs 进行中的

### 人类-AI 分工

**人类角色**：
- 战略决策（推迟什么？）
- 优先级调用（接下来处理哪个 Spec？）
- 质量判断（准备好发布了吗？）
- 范围变更（计划变更时更新 Spec 043）

**AI 角色**：
- 按计划实现单个 Spec
- 标记阻塞项和时间线风险
- 随着工作完成更新 Spec 状态
- 生成内容（文档、测试、代码）

**结果**：人类专注于协调和战略，AI 处理实现。发布成功是因为角色清晰。

### 协调 Spec 的教训

**Do (要做)**：
- ✅ 使阶段和依赖关系显式化
- ✅ 清晰链接到所有相关 Spec
- ✅ 随着计划变更更新 Spec（活文档）
- ✅ 使用状态跟踪 (`lean-spec board`)

**Don't (不要做)**：
- ❌ 期望 AI 做出战略决策
- ❌ 假设 AI 知道优先处理什么
- ❌ 让范围保持隐式
- ❌ 忘记在计划变更时更新 Spec

**关键洞察**：协调 Spec 比实现 Spec 需要更多的人类指导。AI 可以执行计划，但人类必须做出战略决策。

---

## 亲自尝试

想用 Spec 协调一个复杂项目吗？

1. **创建一个协调 Spec** - 像 Spec 043 一样，它链接相关 Spec
2. **使依赖显式化** - 使用 `depends_on` 和 `related` 字段
3. **定义阶段** - 清晰的边界，可衡量的里程碑
4. **作为活文档使用** - 随着计划变更而更新
5. **每日跟踪状态** - 使用 `lean-spec board` 发现阻塞项

**模板**：使用 [Spec 043](https://web.lean-spec.dev/specs/043-official-launch-02) 作为发布或项目协调的模板。

**关键问题**：
- 什么是必要的 vs 锦上添花的？
- 工作项之间的依赖关系是什么？
- 每个阶段的质量关卡是什么？
- 我们如何在没有频繁会议的情况下进行协调？

如果你能回答这些问题，你就准备好用 Spec 进行协调了。

**记住**：协调 Spec 不同于实现 Spec。它们协调人员和优先级，而不仅仅是代码。
