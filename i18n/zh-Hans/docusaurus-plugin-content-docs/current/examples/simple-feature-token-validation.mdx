---
sidebar_position: 2
title: 简单功能 - 令牌验证
---

# 简单功能：基于令牌的验证

:::info 示例概况
- **规范**: [071-simplified-token-validation](https://web.lean-spec.dev/specs/071-simplified-token-validation)
- **类型**: 简单功能
- **复杂度**: 简单
- **完成时间**: ~3 小时（单次会话）
- **标签**: `简单` `验证` `独立`
- **最适合**: 团队学习上下文经济阈值如何指导快速修复。
:::

## 学习目标

- 在验证逻辑中直接应用上下文经济阈值，而不是复合评分。
- 在保持高信噪比的同时，练习在 AI 辅助下重写验证器规范。
- 学习如何捕获实现阶段，即使工作可以在一次会话中完成。

## 背景

### 问题

LeanSpec 有一个使用复合评分（0-100）的复杂度验证系统，权重任意。该系统令人困惑：

- **不透明的评分**："评分 45/100"没有告诉用户哪里出了问题
- **隐藏指标**：5,207 个令牌变成"评分 60" - 用户看不到实际数字
- **误导结果**：带有子规范的大型规范尽管太大却得到"好"的评分
- **任意权重**：令牌评分（0-60）+ 结构修饰符（-30 到 +20）没有明确的理由

### 为什么需要这个规范？

我们刚刚实现了令牌计数（规范 069）并移除了行数验证，改用基于令牌的验证。但实现过于复杂。规范 071 旨在**通过应用第一性原则来简化**：

1. **上下文经济** - 使用直接令牌阈值（2,000 / 3,500 / 5,000）
2. **信噪比** - 报告实际数字，而非派生评分
3. **意图优于实现** - 独立检查每个因素

## 规范

### 关键部分

**设计原则**：用**直接、独立的检查**替换复合评分。

```typescript
// 旧：令人困惑的复合评分
score = tokenScore (0-60) + structureModifier (-30 to +20)
// 结果："评分 45/100" - 这是什么意思？

// 新：直接阈值检查
if (tokens > 5000) return 'error'
if (tokens > 3500) return 'warning'  
if (tokens > 2000) return 'info'
return 'excellent'
```

**令牌阈值**：
- **&lt;2,000 令牌**：优秀 - 最佳 AI 性能
- **2,000-3,500**：良好 - 可接受，注意增长
- **3,500-5,000**：警告 - 考虑拆分
- **>5,000**：错误 - 应为上下文经济而拆分

**实现方法**：
1. 移除评分计算逻辑
2. 实现直接阈值检查
3. 报告实际令牌计数
4. 添加独立结构检查

[查看完整规范 →](https://web.lean-spec.dev/specs/071-simplified-token-validation)

## 实现

### 阶段 1：分析

**要更改的文件**：
- `packages/core/src/validators/complexity.ts` - 主验证逻辑
- `packages/cli/src/commands/validate.ts` - CLI 输出格式化

**方法**：
1. 阅读现有复杂度验证器
2. 识别要移除的评分计算代码
3. 设计新的基于阈值的 API
4. 更新 CLI 以直接显示令牌计数

### 阶段 2：核心更改

**关键代码更改**：

```typescript
// 之前：复杂评分
const tokenScore = Math.max(0, 60 - (tokens - 2000) / 100);
const structureModifier = hasSubSpecs ? -30 : 0;
const score = tokenScore + structureModifier;

// 之后：直接阈值
function validateTokens(tokens: number) {
  if (tokens > 5000) return { level: 'error', message: '...' };
  if (tokens > 3500) return { level: 'warning', message: '...' };
  if (tokens > 2000) return { level: 'info', message: '...' };
  return { level: 'excellent', message: '...' };
}
```

**结构检查变得独立**：
- 子规范不再有评分修饰符
- 每个结构问题都有自己清晰的消息
- 基于实际问题而非评分的建议

### 阶段 3：测试

**验证测试**：
- 每个阈值边界的令牌计数
- 结构检查独立报告
- CLI 输出显示实际数字，而非评分
- 错误消息可操作

## 演进

### 实现期间发生了什么变化？

**1. 移除"带子规范就好"的漏洞**
   - **原始**：子规范给予 -30 修饰符（5K 令牌可以是"好"）
   - **问题**：违反上下文经济原则
   - **更改**：令牌阈值是绝对的，结构检查是独立的

**2. 添加详细内容分解**
   - **发现**：用户想知道令牌来自哪里
   - **添加**：`--detailed` 标志显示散文 vs 代码 vs 表格
   - **影响**：帮助用户识别要提取到子规范的内容

**3. 更清晰的验证消息**
   - **原始**："考虑拆分"（模糊）
   - **改进**："规范有 4,207 个令牌（阈值：3,500）- 考虑简化"
   - **影响**：用户确切知道超过阈值多少

### 挑战

**挑战 1：现有规范的破坏性变化**
- **问题**：12 个规范有评分，现在显示警告
- **解决方案**：在规范中记录，提供迁移指南
- **结果**：迫使我们拆分超大规范（好结果！）

**挑战 2：平衡简单性与功能**
- **问题**：想要每个部分的令牌分析，但增加复杂性
- **决策**：先发布简单版本，后来添加 `--detailed`
- **教训**：渐进式披露 - 在感到痛苦时添加功能

## 结果

### 指标

**之前**：
- 12 个规范带有令人困惑的"评分 45/100"消息
- 用户在 3 个 GitHub 问题中询问"评分是什么意思？"
- 验证假阴性：5K+ 令牌规范标记为"好"

**之后**：
- 100% 的规范显示实际令牌计数
- 关于验证输出的用户问题为零
- 捕获 8 个 >3,500 令牌需要拆分的规范

### 代码影响

**行数变化**：~200 行
- 移除：150 行（评分计算逻辑）
- 添加：50 行（阈值检查）
- 净值：更简单的代码库

**构建时间**：无变化（验证很快）

**测试覆盖率**：从 78% 增加到 92%（更简单的代码 = 更易测试）

## 经验教训

### 有效的做法

✅ **将第一性原则应用于现有代码**
   - 上下文经济 → 直接阈值
   - 信噪比 → 显示实际数字
   - 使验证立即可理解

✅ **小而专注的范围**
   - 仅更改验证逻辑
   - 保持 CLI 命令不变（向后兼容）
   - 在一次会话中完成

✅ **真实的自用**
   - 在我们自己的规范上运行验证发现 8 个超大规范
   - 迫使我们实践所宣扬的（拆分规范）

### 我们会有不同做法的地方

🔄 **规范中更多示例**
   - 规范有代码示例，但可以显示 CLI 输出示例
   - 会帮助更早地可视化用户体验

🔄 **更早地针对真实规范测试**
   - 在实现期间发现边缘情况（有许多表格的规范）
   - 可以先针对实际规范库验证

### 关键要点

**小的、原则驱动的更改具有超大影响。**通过简化验证以匹配第一性原则，我们：
- 使工具更有用
- 减少代码复杂性
- 改进我们自己的规范（自用揭示问题）

## AI 代理协作

### AI 代理如何使用此规范

**GitHub Copilot 代理**：
1. 阅读规范以理解问题和解决方案
2. 识别要更改的确切文件（`complexity.ts`）
3. 实现与规范设计匹配的阈值逻辑
4. 为阈值边界添加测试用例
5. 更新 CLI 输出格式化

**成功因素**：
- **清晰的问题陈述** - 代理理解"为什么"而不仅仅是"什么"
- **代码示例** - 提供要实现的确切 API
- **测试标准** - 代理知道成功是什么样子
- **专注范围** - 单文件更改，清晰边界

**代理自主性**：90% - 代理在最少人类指导下完成实现。人类审查输出并请求一次改进（错误消息措辞）。

### 规范质量促进因素

是什么使这个规范对 AI 代理友好：

1. **具体示例** - 代码片段显示确切的 API
2. **清晰的成功标准** - "显示实际令牌计数"是可衡量的
3. **令牌计数**：1,847 令牌 - 远在上下文经济限制内
4. **单一关注点** - 仅验证逻辑，无 CLI 重新设计

### 人类-AI 协作

**人类角色**：
- 基于第一性原则分析编写规范
- 审查代理实现的原则对齐
- 对破坏性变化做出判断

**AI 角色**：
- 实现代码更改
- 编写测试用例
- 生成验证错误消息

**结果**：功能在规范编写的当天发布。

---

## 自己尝试

想将此模式应用于你的项目？

1. **找到复杂代码** - 寻找评分系统、加权平均
2. **应用第一性原则** - 你实际在测量什么？直接报告
3. **编写专注的规范** - 一个关注点，清晰的问题/解决方案
4. **快速实现** - 小改变复合

**模板**：使用[规范 071](https://web.lean-spec.dev/specs/071-simplified-token-validation)作为简化重构的模板。
