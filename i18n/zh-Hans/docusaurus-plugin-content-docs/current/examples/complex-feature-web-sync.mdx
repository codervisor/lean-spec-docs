---
sidebar_position: 3
title: 复杂功能 - Web 实时同步
---

# 复杂功能：Web 实时同步架构

:::info 示例概况
- **规范**: [082-web-realtime-sync-architecture](https://web.lean-spec.dev/specs/082-web-realtime-sync-architecture)
- **类型**: 架构 / 复杂功能
- **复杂度**: 高（需要子规范）
- **完成时间**: 多阶段（~3+ 周）
- **标签**: `复杂` `架构` `子规范` `AI 配对`
- **最适合**: 规划实时同步、缓存或混合数据管道的团队。
:::

## 学习目标

- 构建通过拆分 DESIGN 细节保持可读性的双模式架构规范。
- 以阶段里程碑捕获长期工作，AI 代理可以并行执行。
- 理解如何为未来贡献者记录速率限制、缓存策略和服务抽象。

## 背景

### 问题

Web 应用需要服务两个具有冲突需求的不同用例：

**用例 1：LeanSpec 自己的规范**（主要）
- 规范位于同一 monorepo（`specs/` 目录）
- 开发期间需要实时更新
- 可用快速文件系统读取
- 无 API 速率限制

**用例 2：外部 GitHub 仓库**（未来）
- 规范在外部公共仓库中
- GitHub API 有速率限制（5,000 请求/小时）
- API 延迟：每个文件 200-500ms
- 需要缓存以提高性能

**当前问题**：规范更改后 Web 应用立即变得陈旧。不存在自动同步机制。

### 为什么需要这个规范？

这是 v0.3.0 发布的 **关键架构决策**。做错了意味着：
- 糟糕的开发者体验（手动重新播种）
- 无法支持多项目展示功能
- 潜在的 GitHub API 速率限制问题
- 用户页面加载缓慢

**v0.3 启动的关键阻碍因素** - 实现前需要架构清晰度。

## 规范

### 关键架构决策

**双模式架构**，具有环境驱动配置：

```
┌─────────────────────────────────────────────────────────────┐
│                      Web 应用 (Next.js)                      │
├─────────────────────────────────────────────────────────────┤
│                    统一服务层                                │
│                  (SpecsService 抽象)                        │
├──────────────────────────┬──────────────────────────────────┤
│   模式 1：文件系统       │   模式 2：数据库 + GitHub        │
│   (本地规范)            │   (外部仓库)                     │
│                          │                                  │
│   specs/ 目录 ──────────┤─── GitHub API ─→ SQLite 缓存    │
│   内存缓存               │   计划同步                       │
│   &lt;100ms 读取           │   Webhook 更新（可选）           │
│   无需数据库             │   速率限制感知                   │
└──────────────────────────┴──────────────────────────────────┘
```

### 应用的设计原则

1. **上下文经济** - 规范拆分为主 README + 子规范：
   - `README.md` - 问题、决策、高层设计
   - `DESIGN.md` - 详细实现（后来创建）

2. **意图优于实现** - 关注每种模式存在的"为什么"：
   - 模式 1：实时开发工作流
   - 模式 2：支持外部仓库而无速率限制

3. **跨越鸿沟** - 人类和 AI 理解的清晰架构图

### 令牌计数

**主规范**：3,847 令牌（在可接受范围内）
**加 DESIGN.md**：6,200+ 令牌（需要拆分）

[查看完整规范 →](https://web.lean-spec.dev/specs/082-web-realtime-sync-architecture)

## 实现

### 阶段 1：文件系统模式（MVP）

**目标**：首先为 LeanSpec 自己的规范发布实时同步。

**实现方法**：
1. 创建 `FilesystemSpecsSource` 适配器
2. 使用 fs.watch 实现内存缓存
3. 使用本地 specs/ 目录测试
4. 部署到生产环境

**代码结构**：
```typescript
interface SpecsSource {
  getSpecs(): Promise<SpecInfo[]>;
  getSpec(id: string): Promise<SpecInfo>;
  watch(callback: () => void): void;
}

class FilesystemSpecsSource implements SpecsSource {
  private cache = new Map();
  private watcher: fs.FSWatcher;
  
  constructor(specsPath: string) {
    this.watcher = fs.watch(specsPath, () => {
      this.cache.clear();
    });
  }
}
```

**时间线**：第 1-2 周

### 阶段 2：数据库模式（未来）

**推迟到后续迭代** - 专注于首先发布模式 1。

**计划方法**：
1. 使用 Prisma 添加 SQLite 数据库
2. 创建 `DatabaseSpecsSource` 适配器
3. 实现 GitHub API → DB 同步
4. 添加计划同步作业

**为什么推迟？**：
- 模式 1 解除 v0.3.0 启动阻碍
- 可以用更简单的实现验证架构
- 在添加复杂性之前从生产使用中学习

### 阶段 3：配置层

**环境驱动的模式选择**：
```typescript
// .env
SPECS_MODE=filesystem  # 或 'database'
SPECS_PATH=./specs     # 用于文件系统模式
DATABASE_URL=...       # 用于数据库模式
```

**智能默认值**：
- 本地开发 → 文件系统模式
- 带本地规范的生产环境 → 文件系统模式
- 多项目展示 → 数据库模式

## 演进

### 实现期间发生了什么变化？

**1. 范围缩减**
   - **原始计划**：立即实现两种模式
   - **现实**：仅文件系统模式即可解除 v0.3.0 阻碍
   - **决策**：发布模式 1，推迟模式 2
   - **教训**：渐进式披露 - 在需要时添加复杂性

**2. 缓存策略**
   - **原始**：磁盘上的持久缓存
   - **问题**：缓存失效复杂性
   - **更改**：内存缓存 + fs.watch 失效
   - **好处**：更简单、更快、无陈旧数据

**3. 子规范创建**
   - **时机**：主规范达到 3,500 令牌后
   - **原因**：实现细节使 README 过长
   - **解决方案**：为技术细节创建 `DESIGN.md`
   - **影响**：主 README 保持可读，DESIGN.md 作为实现参考

**4. Webhook 支持**
   - **原始**：实时更新需要 webhook
   - **现实**：文件系统模式的 fs.watch 足够
   - **更改**：Webhook 标记为可选，仅用于数据库模式
   - **教训**：不要为假设需求过度设计

### 挑战

**挑战 1：平衡灵活性与简单性**
- **问题**：双模式架构增加抽象
- **权衡**：代码更复杂，但支持未来增长
- **缓解**：从更简单的模式开始，推迟数据库复杂性
- **结果**：架构允许增长而无需重写

**挑战 2：令牌计数蔓延**
- **问题**：规范随实现细节增长到 4,200+ 令牌
- **解决方案**：在 3,500 令牌阈值拆分为 README + DESIGN.md
- **学习**：即使架构规范也需要拆分
- **工具**：使用 `lean-spec tokens 082` 监控

**挑战 3：需求不明确**
- **问题**：数据库模式需求未完全理解
- **决策**：不要为你尚未理解的事物编写规范
- **行动**：标记为"阶段 2：未来"，专注于已验证的用例
- **原则**：意图优于实现 - 在需要之前推迟决策

## 结果

### 当前状态（进行中）

**已完成**：
- ✅ 架构决策已记录
- ✅ 文件系统模式已实现
- ✅ 使用 fs.watch 的内存缓存
- ✅ 生产部署
- ✅ 实时更新工作中

**进行中**：
- ⏳ 性能监控
- ⏳ 生产验证
- ⏳ 数据库模式需求完善

**已推迟**：
- 📅 数据库模式实现
- 📅 GitHub API 同步
- 📅 多项目支持

### 指标

**性能（文件系统模式）**：
- 平均读取时间：45ms（目标：&lt;100ms）✅
- 预热后缓存命中率：95% ✅
- 90 个规范的内存使用：~10MB ✅
- 构建时间：无变化 ✅

**开发者体验**：
- 规范更改立即可见（无手动同步）✅
- 开发中热重载工作 ✅
- 本地开发零配置 ✅

### 代码影响

**创建的文件**：
- `packages/web/src/lib/sources/filesystem.ts` - 250 行
- `packages/web/src/lib/sources/types.ts` - 80 行
- 测试 - 150 行

**架构更改**：
- 引入 `SpecsSource` 抽象
- 为多源支持做准备
- 保持向后兼容性

## 经验教训

### 有效的做法

✅ **规范增长过大时拆分**
   - 使用 `lean-spec tokens` 在 3,500 令牌时捕获
   - 将实现细节移至 DESIGN.md
   - 保持 README 专注于决策理由

✅ **推迟复杂性**
   - 首先发布文件系统模式
   - 在添加数据库之前验证架构
   - 现在可以从生产使用中学习

✅ **架构图**
   - 视觉表示桥接人类-AI 理解
   - 使权衡明确
   - 审查者快速理解方法

✅ **渐进式实现**
   - 阶段 1 解除启动阻碍
   - 阶段 2 可以根据实际使用情况制定
   - 避免过度设计

### 我们会有不同做法的地方

🔄 **更早地监控令牌**
   - 规范在我们注意到之前达到 4,200 令牌
   - 应该设置令牌阈值警报
   - 会更早拆分，保持流畅

🔄 **更具体的示例**
   - 规范在架构上很重，在示例上很轻
   - 应该包含每种模式的代码示例
   - 会加速实现

🔄 **更清晰的阶段边界**
   - 阶段 1/2 区别在实现期间演变
   - 应该提前明确范围
   - 会避免"范围蔓延"讨论

### 关键要点

**1. 大型规范需要子规范**
   - 不要试图将所有内容放入 README
   - 在 3,500 令牌而非 5,000 令牌拆分
   - 主动使用 `lean-spec tokens`

**2. 推迟你能推迟的**
   - 发布最小可行架构
   - 在添加复杂性之前从生产中学习
   - 渐进式披露也适用于功能

**3. 架构规范不同**
   - 需要更多图表，更少代码
   - 关注权衡和理由
   - 实现细节属于子规范

**4. 主动监控令牌计数**
   - 频繁运行 `lean-spec tokens <spec>`
   - 在 CI 中设置验证
   - 在达到痛苦阈值之前拆分

## AI 代理协作

### AI 代理如何使用此规范

**GitHub Copilot 代理**：
1. 阅读主 README 了解架构决策
2. 参考 DESIGN.md 了解实现细节
3. 实现与接口设计匹配的 `FilesystemSpecsSource`
4. 根据性能要求添加缓存逻辑
5. 创建与成功标准匹配的测试

**挑战**：
- **令牌计数**：README 中 3,847 令牌（接近限制）
- **上下文切换**：必须同时参考 README + DESIGN.md
- **解决方案**：代理先读 README，然后读 DESIGN.md 了解详情

**成功因素**：
- 清晰的架构图（视觉 = 快速理解）
- 明确的接口定义（SpecsSource）
- 性能目标（< 100ms 读取）
- 阶段 1/2 拆分使范围清晰

**代理自主性**：75% - 代理在指导下实现文件系统模式。人类提供缓存策略和范围决策的过程修正。

### 规范质量挑战

是什么使这个规范对 AI 代理更困难：

1. **高令牌计数** - 接近上下文经济阈值
2. **多文件结构** - README + DESIGN.md 需要导航
3. **架构决策** - 需要理解权衡，而不仅仅是实现
4. **演进范围** - 阶段 2 在实现中期推迟

**缓解策略**：
- 早期（而非后期）拆分为子规范
- 使用图表快速理解
- 提前明确阶段边界
- 清晰地链接 README 和子规范

### 人类-AI 劳动分工

**人类角色**：
- 架构决策（双模式 vs 单模式）
- 范围管理（推迟阶段 2）
- 权衡分析（复杂性 vs 灵活性）
- 生产中的性能验证

**AI 角色**：
- 文件系统源的实现
- 缓存逻辑实现
- 测试用例生成
- 文档更新

**结果**：架构复杂性需要比简单功能（规范 071）更多的人类指导，但 AI 仍实现了 75% 的代码。

---

## 自己尝试

想处理复杂的架构决策？

1. **从决策开始，而非实现** - 首先记录"为什么"
2. **使用图表** - 视觉理解快 10 倍
3. **在 3,500 令牌时拆分** - 不要等到 5,000
4. **推迟复杂性** - 发布阶段 1，学习，然后构建阶段 2
5. **监控令牌计数** - 频繁运行 `lean-spec tokens <spec>`

**模板**：使用[规范 082](https://web.lean-spec.dev/specs/082-web-realtime-sync-architecture)作为需要分阶段实现的架构决策模板。

**关键问题**：你能发布一个验证架构的更简单版本吗？从那里开始。
