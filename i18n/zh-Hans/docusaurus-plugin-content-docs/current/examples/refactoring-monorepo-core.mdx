---
sidebar_position: 4
title: 重构 - Monorepo 核心提取
---

# 重构：Monorepo 核心提取

:::info 示例概况
- **Spec**: [067-monorepo-core-extraction](https://web.lean-spec.dev/specs/067-monorepo-core-extraction)
- **类型**: 重构 / 平台提取
- **复杂度**: 高 (破坏性变更)
- **完成时间**: ~1 周
- **过滤器**: `Complex` `Refactor` `Breaking Change`
- **适用场景**: 需要将共享逻辑拆分到包中而不暂停功能开发的团队。
:::

## 学习目标

- 制定具有清晰依赖顺序和回滚计划的破坏性变更计划。
- 捕获适配器抽象，以便 AI 代理可以安全地实现新的存储后端。
- 协调 CLI、核心和 Web 包，防止正在进行的回归问题泄漏。

## 背景

### 问题

LeanSpec 需要一个 Web 应用程序来展示实时 Spec (spec 035)。但是约 40% 的 CLI 代码库与 Node.js 文件系统操作紧密耦合：

```typescript
// 与 fs 紧密耦合
function loadSpec(specId: string): SpecInfo {
  const path = `specs/${specId}/README.md`;
  const content = fs.readFileSync(path, 'utf-8');
  return parseSpec(content);
}
```

**困境**：
- Web 应用需要与 CLI 相同的解析/验证逻辑
- Web 应用从 GitHub API 读取，而不是文件系统
- 复制代码会导致偏差和不一致
- 需要适用于两种存储后端的共享逻辑

### 为什么制定此 Spec？

**关键决策点**：在构建 Web 应用之前重构，还是复制代码？

**如果不重构**：
- Web 应用复制 2,000+ 行解析/验证代码
- CLI 和 Web 实现逐渐偏离
- 在一个地方修复的 Bug，在另一个地方没修
- 不一致的行为困扰用户

**如果重构**：
- 共享的 `@leanspec/core` 包确保一致性
- 破坏性变更需要仔细迁移
- 一次性痛苦，长期可维护性

**决策**：现在重构。未来的我们会感谢现在的我们。

## Spec 内容

### 架构决策

具有共享核心包的 **Monorepo 结构**：

```
lean-spec/
├── packages/
│   ├── core/                 # 🎯 新增：共享逻辑
│   │   ├── types/            # 平台无关类型
│   │   ├── parsers/          # Spec 解析
│   │   ├── validators/       # 验证逻辑
│   │   └── utils/            # 统计，过滤器
│   │
│   ├── cli/                  # 🔧 现有：CLI/MCP
│   │   ├── commands/
│   │   └── adapters/
│   │       └── fs-storage.ts # 文件系统适配器
│   │
│   └── web/                  # 🌐 未来：Web 应用
│       └── adapters/
│           └── github-storage.ts  # GitHub 适配器
```

### 关键设计决策

**1. 抽象存储接口**

定义抽象接口，而不是耦合到 `fs`：

```typescript
// packages/core/src/types/storage.ts
interface SpecStorage {
  listSpecs(): Promise<string[]>;
  readSpec(id: string): Promise<string>;
  readSubSpec(id: string, file: string): Promise<string>;
}
```

**2. 依赖注入**

核心函数接收 storage，而不是全局 `fs`：

```typescript
// 之前（紧密耦合）
function loadSpec(id: string): SpecInfo {
  const content = fs.readFileSync(`specs/${id}/README.md`);
  return parseSpec(content);
}

// 之后（依赖注入）
function loadSpec(
  id: string,
  storage: SpecStorage
): Promise<SpecInfo> {
  const content = await storage.readSpec(id);
  return parseSpec(content);
}
```

**3. CLI 适配器**

CLI 提供文件系统实现：

```typescript
// packages/cli/src/adapters/fs-storage.ts
class FileSystemStorage implements SpecStorage {
  constructor(private specsPath: string) {}
  
  async readSpec(id: string): Promise<string> {
    return fs.readFile(`${this.specsPath}/${id}/README.md`, 'utf-8');
  }
}
```

**4. 构建配置**

使用 `tsup` 将 core 打包进 CLI（无运行时依赖）：

```typescript
// packages/cli/tsup.config.ts
export default defineConfig({
  noExternal: ['@leanspec/core'],  // 打包 core，运行时不需要
});
```

**重要原因**：发布的 CLI 包是自包含的，没有 `workspace:*` 依赖。

[查看完整 Spec →](https://web.lean-spec.dev/specs/067-monorepo-core-extraction)

## 实现

### 第一阶段：设置 Monorepo（第 1 天）

**步骤**：
1. 创建 `pnpm-workspace.yaml`
2. 创建 `packages/core` 目录
3. 设置 TypeScript 构建配置
4. 配置 Turborepo 进行构建编排

**挑战**：
- Turborepo 缓存配置
- 本地开发的 TypeScript 路径映射
- 构建顺序（core 必须在 cli/web 之前构建）

**解决方案**：
```yaml
# pnpm-workspace.yaml
packages:
  - 'packages/*'

# turbo.json
{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],  # 先构建依赖项
      "outputs": ["dist/**"]
    }
  }
}
```

### 第二阶段：提取核心逻辑（第 2-3 天）

**提取策略**：
1. 首先移动类型（无依赖）
2. 移动解析器（依赖类型）
3. 移动验证器（依赖解析器）
4. 最后移动工具（依赖所有内容）

**代码迁移**：
```bash
# 类型（0 外部依赖）
src/types/ → packages/core/src/types/

# 解析器（~300 行）
src/parsers/frontmatter.ts → packages/core/src/parsers/

# 验证器（~500 行）  
src/validators/*.ts → packages/core/src/validators/

# 工具（~200 行）
src/utils/stats.ts → packages/core/src/utils/
```

**关键重构**：
- 从 core 中移除所有 `fs` 导入
- 将同步函数更改为异步（GitHub API 是异步的）
- 向所有公共函数添加 `SpecStorage` 参数

### 第三阶段：创建 CLI 适配器（第 4 天）

**实现**：
```typescript
// packages/cli/src/adapters/fs-storage.ts
export class FileSystemStorage implements SpecStorage {
  constructor(private specsPath: string) {}

  async listSpecs(): Promise<string[]> {
    const entries = await fs.readdir(this.specsPath, { withFileTypes: true });
    return entries
      .filter(e => e.isDirectory() && /^\d{3}-/.test(e.name))
      .map(e => e.name);
  }

  async readSpec(id: string): Promise<string> {
    return fs.readFile(
      path.join(this.specsPath, id, 'README.md'),
      'utf-8'
    );
  }

  async readSubSpec(id: string, file: string): Promise<string> {
    return fs.readFile(
      path.join(this.specsPath, id, file),
      'utf-8'
    );
  }
}
```

**集成**：
```typescript
// packages/cli/src/cli.ts
const storage = new FileSystemStorage('./specs');
const specs = await listSpecs(storage);  // 核心函数 + CLI 适配器
```

### 第四阶段：更新 CLI 命令（第 5-6 天）

**每个命令**都需要适配器：
- `lean-spec list` - 传递 storage 给 `listSpecs()`
- `lean-spec view` - 传递 storage 给 `loadSpec()`
- `lean-spec validate` - 传递 storage 给 `validateSpec()`

**模式**：
```typescript
// 之前
async function listCommand() {
  const specs = getSpecs();  // 直接读取 fs
  console.log(specs);
}

// 之后  
async function listCommand() {
  const storage = new FileSystemStorage('./specs');
  const specs = await getSpecs(storage);  // 注入 storage
  console.log(specs);
}
```

### 第五阶段：修复测试（第 7 天）

**测试更新**：
- 为单元测试创建模拟 storage
- 更新集成测试以使用适配器
- 添加适配器特定测试

**模拟 Storage**：
```typescript
class MockStorage implements SpecStorage {
  private specs = new Map<string, string>();
  
  async readSpec(id: string): Promise<string> {
    return this.specs.get(id) || '';
  }
  
  // 测试辅助函数
  setSpec(id: string, content: string) {
    this.specs.set(id, content);
  }
}
```

**好处**：
- 测试无需文件系统即可运行
- 更快的测试执行
- 可以测试边缘情况（格式错误的 Spec）

### 第六阶段：构建与发布（第 7 天）

**关键**：确保 `@leanspec/core` 被打包，而不是作为外部依赖。

**问题**：pnpm workspaces 使用 `workspace:*` 协议：
```json
{
  "dependencies": {
    "@leanspec/core": "workspace:*"  // ❌ 破坏发布的包
  }
}
```

**解决方案**：使用 tsup 打包 core，从依赖中移除：
```typescript
// packages/cli/tsup.config.ts
export default defineConfig({
  noExternal: ['@leanspec/core'],  // 打包进 dist/
});
```

**验证**：
```bash
# 构建
pnpm build

# 检查发布的包内容
cd packages/cli/dist
ls -la  # 应包含打包的 core 代码

# 验证没有 workspace 依赖
npm pack --dry-run
# 检查依赖 - 不应包含 @leanspec/core
```

## 演进

### 实施过程中有什么变化？

**1. 构建配置复杂性**
   - **意外**：包之间的 TypeScript 路径映射中断
   - **解决方案**：使用 `tsconfig.json` 引用
   - **教训**：Monorepo 需要仔细的构建编排

**2. 异步转换**
   - **最初**：核心函数是同步的
   - **问题**：GitHub API 是异步的，需要通用接口
   - **变更**：将所有核心函数改为异步
   - **影响**：CLI 代码需要到处添加 `await`

**3. 测试策略**
   - **最初**：测试使用真实文件系统
   - **机会**：模拟 storage 实现更好的测试
   - **变更**：切换到基于模拟的单元测试
   - **好处**：测试执行速度提高 10 倍

**4. 打包配置**
   - **发现**：`workspace:*` 依赖破坏发布的包
   - **根本原因**：npm 不识别 pnpm workspace 协议
   - **解决方案**：使用 `noExternal` 打包 core
   - **关键**：如果没有这个，发布的包就会损坏

### 挑战

**挑战 1：破坏性变更**
   - **问题**：所有现有代码导入都变了
   - **范围**：50+ 个文件需要更新
   - **缓解**：使用 IDE 重构工具
   - **验证**：每个阶段后运行完整测试套件

**挑战 2：构建编排**
   - **问题**：如果 core 没有先构建，CLI 构建会失败
   - **解决方案**：Turborepo `dependsOn: ["^build"]`
   - **复杂性**：core 变更时的缓存失效
   - **结果**：冷构建增加了 30 秒，但热构建很快

**挑战 3：类型保留**
   - **问题**：TypeScript 类型有时在包之间丢失
   - **解决方案**：在 core `index.ts` 中显式导出类型
   - **教训**：要有意设计公共 API 表面

**挑战 4：开发者体验**
   - **问题**：本地开发需要先构建 core
   - **解决方案**：`pnpm build:templates && turbo run build`
   - **文档**：在 CONTRIBUTING.md 中更新了设置步骤

## 结果

### 指标

**代码组织**：
- Core 包：1,200 行（纯逻辑）
- CLI 包：800 行（命令 + 适配器）
- Web 包：准备好实现
- 代码复用：~60% 的逻辑现在共享

**构建性能**：
- 冷构建：+30秒 (core + cli + web)
- 热构建：无变化 (turbo 缓存)
- 测试执行：-50% 时间 (模拟 storage)

**破坏性变更**：
- 文件变更：52
- 测试更新：38
- 构建配置：5 个新文件
- 迁移时间：1 周

### 开发者影响

**之前**：
- CLI 和未来的 Web 将复制代码
- 文件系统耦合阻碍了测试
- 变更需要编辑多个地方

**之后**：
- 核心逻辑在所有包之间共享
- 清晰的抽象实现了轻松测试
- 解析/验证的单一事实来源

### 风险缓解

**Spec 如何防止问题**：
- ✅ 明确的迁移计划防止了遗漏边缘情况
- ✅ 测试策略确保无回归
- ✅ 记录的构建配置防止了发布问题
- ✅ 回滚计划（保留在 Spec 中）赋予了信心

**可能出什么问题**：
- 发布带有 `workspace:*` 依赖的包 → 会破坏用户使用
- 缺少同步到异步的转换 → 稍后会破坏 Web 应用
- 没有测试更新 → 会导致 CI 失败
- 破坏 CLI 而没有迁移指南 → 会让用户陷入困境

## 经验教训

### 成功的做法

✅ **Spec 驱动的重构**
   - 明确的计划防止了错误
   - 可以轻松暂停和恢复工作
   - 团队可以在实施前审查方法

✅ **分阶段实施**
   - 一次一个包 (core → cli → web)
   - 可以在继续之前验证每个阶段
   - 降低了一次性破坏所有内容的风险

✅ **全面的测试**
   - 测试更新与代码变更在同一个 PR 中
   - 模拟 storage 实现了更好的单元测试
   - 在合并前捕获了问题

✅ **关注构建配置**
   - 在 Spec 中记录了打包策略
   - 在发布前捕获了 `workspace:*` 问题
   - Spec 审查者发现了潜在问题

### 我们会做得不同的地方

🔄 **更早进行异步转换**
   - 在实施中途意识到需要时才做
   - 本应包含在原始 Spec 设计中
   - 本可以节省返工

🔄 **更好的进度跟踪**
   - 应该使用 `lean-spec update 067 --status in-progress`
   - Spec 状态直到完成前一直保持 `planned`
   - 失去了进度的可见性

🔄 **增量提交**
   - 大型 PR（~1,500 行变更）
   - 应该按阶段拆分为多个 PR
   - 本可以更容易审查

### 关键要点

**1. Spec 降低重构风险**
   - 明确的计划在编码前暴露问题
   - 可以与团队讨论方法
   - 如果需要，提供回滚计划

**2. 重构是投资**
   - 1 周的工作换取长期的可维护性
   - 赋能未来功能（Web 应用）
   - 测试变得更快、更可靠

**3. 构建配置很重要**
   - Monorepo 工具具有锋利的边缘（容易出错）
   - 打包策略影响发布的包
   - 记录不明显的配置决策

**4. 破坏性变更需要谨慎**
   - 迁移指南至关重要
   - 测试覆盖率赋予信心
   - 分阶段推出降低风险

## AI 代理协作

### AI 代理如何使用此 Spec

**GitHub Copilot 代理**：
1. 阅读 Spec 以了解重构范围
2. 根据提取计划移动文件
3. 更新了 50+ 个文件的导入
4. 实现了匹配接口的 `FileSystemStorage` 适配器
5. 将同步函数转换为异步
6. 更新测试文件以使用模拟 storage

**AI 面临的挑战**：
- **大范围**：52 个文件中的 1,500 行变更
- **构建系统**：需要理解 tsup, turborepo
- **测试策略**：需要判断模拟什么
- **错误恢复**：构建失败需要诊断

**成功因素**：
- **明确的文件移动计划** - 代理知道将什么移动到哪里
- **接口定义** - 清晰的 `SpecStorage` 契约
- **记录的测试策略** - 代理知道创建模拟 storage
- **构建配置示例** - Spec 包含 tsup 配置

**代理自主性**：60% - 代理处理了文件移动和导入更新。人类提供了关于构建配置、异步转换策略和测试方法的指导。

### Spec 质量挑战

**什么让 AI 更难处理**：

1. **大范围** - 触及 52 个文件难以协调
2. **构建系统复杂性** - Monorepo 工具需要专业知识
3. **判断调用** - 异步转换策略不明确
4. **系统级思维** - 理解包边界

**什么帮助 AI 成功**：

1. **分阶段计划** - 清晰的步骤（设置 → 提取 → 适配 → 测试）
2. **代码示例** - Spec 展示了确切的接口和模式
3. **测试策略** - 关于模拟的明确指导
4. **风险缓解** - Spec 指出了 `workspace:*` 问题

### 人机分工

**人类角色**：
- 架构决策（monorepo vs 替代方案）
- 构建配置 (tsup, turborepo)
- 异步转换策略
- 风险评估和验证

**AI 角色**：
- 根据计划移动文件
- 导入路径更新（机械性）
- 测试文件更新
- 模拟 storage 实现

**结果**：重构在 1 周内完成，而没有 AI 协助预计需要 2 周。人类专注于架构和验证，AI 处理机械性变更。

### AI 辅助重构的经验教训

**建议**：
- ✅ 分解为清晰的阶段
- ✅ 提供接口定义
- ✅ 包含适配器的代码示例
- ✅ 记录不明显的配置

**不建议**：
- ❌ 期望 AI 做出架构决策
- ❌ 假设 AI 理解构建工具的细微差别
- ❌ 让判断调用含糊不清
- ❌ 跳过验证步骤

**关键见解**：当给出明确计划时，AI 擅长机械性重构。人类提供架构和判断。

---

## 亲自尝试

想要自信地重构吗？

1. **先写 Spec** - 编码前计划，尽早暴露问题
2. **分阶段工作** - 分解为可验证的块
3. **同步更新测试** - 不要留到以后
4. **记录构建配置** - 不明显的决策需要解释
5. **制定回滚计划** - Spec 应包含如何撤销更改

**模板**：使用 [spec 067](https://web.lean-spec.dev/specs/067-monorepo-core-extraction) 作为需要仔细协调的破坏性重构的模板。

**关键问题**：
- 如果出错会破坏什么？
- 我们如何验证每个阶段？
- 我们可以安全回滚吗？

如果你能回答这些问题，你就准备好重构了。
