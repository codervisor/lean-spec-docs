---
sidebar_position: 3
title: Complex Feature - Web Realtime Sync
---

# Complex Feature: Web Realtime Sync Architecture

:::info Example Profile
- **Spec**: [082-web-realtime-sync-architecture](https://web.lean-spec.dev/specs/082-web-realtime-sync-architecture)
- **Type**: Architecture / Complex Feature
- **Complexity**: High (requires sub-specs)
- **Time to complete**: Multi-phase (~3+ weeks)
- **Filters**: `Complex` `Architecture` `Sub-specs` `AI Pairing`
- **Best for**: Teams planning realtime sync, caching, or hybrid data pipelines.
:::

## Learning Objectives

- Structure a dual-mode architecture spec that stays readable by splitting DESIGN details.
- Capture long-running work in phased milestones that AI agents can execute in parallel.
- Understand how to document rate limits, caching strategies, and service abstractions for future contributors.

## Context

### The Problem

The web application needed to serve two distinct use cases with conflicting requirements:

**Use Case 1: LeanSpec's Own Specs** (Primary)
- Specs live in same monorepo (`specs/` directory)
- Need realtime updates during development
- Fast filesystem reads available
- No API rate limits

**Use Case 2: External GitHub Repos** (Future)
- Specs in external public repositories
- GitHub API has rate limits (5,000 requests/hour)
- API latency: 200-500ms per file
- Need caching for performance

**Current Problem**: Web app became stale immediately after spec changes. No automatic sync mechanism existed.

### Why This Spec?

This was a **critical architectural decision** for the v0.3.0 release. Getting it wrong would mean:
- Poor developer experience (manual re-seeding)
- Cannot support multi-project showcase feature
- Potential GitHub API rate limit issues
- Slow page loads for users

**Critical blocker for v0.3 launch** - Needed architectural clarity before implementation.

## The Spec

### Key Architecture Decision

**Dual-Mode Architecture** with environment-driven configuration:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Web App (Next.js)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Unified Service Layer                     â”‚
â”‚                  (SpecsService Abstraction)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Mode 1: Filesystem     â”‚   Mode 2: Database + GitHub      â”‚
â”‚   (Local Specs)          â”‚   (External Repos)               â”‚
â”‚                          â”‚                                  â”‚
â”‚   specs/ directory â”€â”€â”€â”€â”€â”€â”¤â”€â”€â”€ GitHub API â”€â†’ SQLite cache   â”‚
â”‚   In-memory cache        â”‚   Scheduled sync                 â”‚
â”‚   &lt;100ms reads           â”‚   Webhook updates (optional)     â”‚
â”‚   No database needed     â”‚   Rate limit aware              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Design Principles Applied

1. **Context Economy** - Spec split into main README + sub-specs:
   - `README.md` - Problem, decision, high-level design
   - `DESIGN.md` - Detailed implementation (created later)

2. **Intent Over Implementation** - Focused on "why" each mode exists:
   - Mode 1: Realtime development workflow
   - Mode 2: Support external repos without rate limits

3. **Bridge the Gap** - Clear architecture diagram for both human and AI understanding

### Token Count

**Main spec**: 3,847 tokens (within acceptable range)
**With DESIGN.md**: 6,200+ tokens (needs splitting)

[View full spec â†’](https://web.lean-spec.dev/specs/082-web-realtime-sync-architecture)

## Implementation

### Phase 1: Filesystem Mode (MVP)

**Goal**: Ship realtime sync for LeanSpec's own specs first.

**Implementation approach**:
1. Create `FilesystemSpecsSource` adapter
2. Implement in-memory caching with fs.watch
3. Test with local specs/ directory
4. Deploy to production

**Code structure**:
```typescript
interface SpecsSource {
  getSpecs(): Promise<SpecInfo[]>;
  getSpec(id: string): Promise<SpecInfo>;
  watch(callback: () => void): void;
}

class FilesystemSpecsSource implements SpecsSource {
  private cache = new Map();
  private watcher: fs.FSWatcher;
  
  constructor(specsPath: string) {
    this.watcher = fs.watch(specsPath, () => {
      this.cache.clear();
    });
  }
}
```

**Timeline**: Week 1-2

### Phase 2: Database Mode (Future)

**Deferred to later sprint** - Focus on shipping Mode 1 first.

**Planned approach**:
1. Add SQLite database with Prisma
2. Create `DatabaseSpecsSource` adapter
3. Implement GitHub API â†’ DB sync
4. Add scheduled sync job

**Why deferred?**:
- Mode 1 unblocks v0.3.0 launch
- Can validate architecture with simpler implementation
- Learn from production usage before adding complexity

### Phase 3: Configuration Layer

**Environment-driven mode selection**:
```typescript
// .env
SPECS_MODE=filesystem  # or 'database'
SPECS_PATH=./specs     # for filesystem mode
DATABASE_URL=...       # for database mode
```

**Smart defaults**:
- Local development â†’ Filesystem mode
- Production with local specs â†’ Filesystem mode
- Multi-project showcase â†’ Database mode

## Evolution

### What Changed During Implementation?

**1. Scope Reduction**
   - **Original plan**: Implement both modes immediately
   - **Reality**: Filesystem mode alone unblocks v0.3.0
   - **Decision**: Ship Mode 1, defer Mode 2
   - **Lesson**: Progressive disclosure - add complexity when needed

**2. Caching Strategy**
   - **Original**: Persistent cache on disk
   - **Problem**: Cache invalidation complexity
   - **Change**: In-memory cache + fs.watch for invalidation
   - **Benefit**: Simpler, faster, no stale data

**3. Sub-Spec Creation**
   - **When**: After main spec reached 3,500 tokens
   - **Why**: Implementation details made README too long
   - **Solution**: Created `DESIGN.md` for technical details
   - **Impact**: Main README stayed readable, DESIGN.md for implementation reference

**4. Webhook Support**
   - **Original**: Required webhooks for realtime updates
   - **Reality**: fs.watch is sufficient for filesystem mode
   - **Change**: Webhooks marked optional, only for database mode
   - **Lesson**: Don't over-engineer for hypothetical requirements

### Challenges

**Challenge 1: Balancing Flexibility vs Simplicity**
- **Issue**: Dual-mode architecture adds abstraction
- **Trade-off**: More complex code, but supports future growth
- **Mitigation**: Start with simpler mode, defer database complexity
- **Outcome**: Architecture allows growth without rewrite

**Challenge 2: Token Count Creep**
- **Issue**: Spec grew to 4,200+ tokens with implementation details
- **Solution**: Split into README + DESIGN.md at 3,500 token threshold
- **Learning**: Even architectural specs need splitting
- **Tool**: Used `lean-spec tokens 082` to monitor

**Challenge 3: Unclear Requirements**
- **Issue**: Database mode requirements not fully understood
- **Decision**: Don't spec what you don't understand yet
- **Action**: Mark as "Phase 2: Future", focus on validated use case
- **Principle**: Intent Over Implementation - defer decisions until needed

## Outcome

### Current Status (In Progress)

**Completed**:
- âœ… Architecture decision documented
- âœ… Filesystem mode implemented
- âœ… In-memory caching with fs.watch
- âœ… Production deployment
- âœ… Realtime updates working

**In Progress**:
- â³ Performance monitoring
- â³ Production validation
- â³ Database mode requirements refinement

**Deferred**:
- ğŸ“… Database mode implementation
- ğŸ“… GitHub API sync
- ğŸ“… Multi-project support

### Metrics

**Performance (Filesystem Mode)**:
- Average read time: 45ms (target: &lt;100ms) âœ…
- Cache hit rate: 95% after warmup âœ…
- Memory usage: ~10MB for 90 specs âœ…
- Build time: No change âœ…

**Developer Experience**:
- Spec changes visible immediately (no manual sync) âœ…
- Hot reload works in development âœ…
- Zero configuration for local development âœ…

### Code Impact

**Files created**:
- `packages/web/src/lib/sources/filesystem.ts` - 250 lines
- `packages/web/src/lib/sources/types.ts` - 80 lines
- Tests - 150 lines

**Architecture changes**:
- Introduced `SpecsSource` abstraction
- Prepared for multi-source support
- Maintained backward compatibility

## Lessons

### What Worked

âœ… **Splitting the spec when it grew too large**
   - Used `lean-spec tokens` to catch at 3,500 tokens
   - Moved implementation details to DESIGN.md
   - Kept README focused on decision rationale

âœ… **Deferring complexity**
   - Shipped filesystem mode first
   - Validated architecture before adding database
   - Can now learn from production usage

âœ… **Architecture diagram**
   - Visual representation bridged human-AI understanding
   - Made trade-offs explicit
   - Reviewers quickly understood the approach

âœ… **Progressive implementation**
   - Phase 1 unblocked launch
   - Phase 2 can be informed by real usage
   - Avoided over-engineering

### What We'd Do Differently

ğŸ”„ **Token monitoring earlier**
   - Spec hit 4,200 tokens before we noticed
   - Should have set up token threshold alerts
   - Would have split earlier, maintaining flow

ğŸ”„ **More concrete examples**
   - Spec was heavy on architecture, light on examples
   - Should have included code examples for each mode
   - Would have accelerated implementation

ğŸ”„ **Clearer phase boundaries**
   - Phase 1/2 distinction evolved during implementation
   - Should have made scope explicit upfront
   - Would have avoided "scope creep" discussions

### Key Takeaways

**1. Large specs need sub-specs**
   - Don't try to fit everything in README
   - Split at 3,500 tokens, not 5,000
   - Use `lean-spec tokens` proactively

**2. Defer what you can**
   - Ship minimum viable architecture
   - Learn from production before adding complexity
   - Progressive disclosure applies to features too

**3. Architecture specs are different**
   - Need more diagrams, less code
   - Focus on trade-offs and rationale
   - Implementation details belong in sub-specs

**4. Monitor token counts actively**
   - Run `lean-spec tokens <spec>` frequently
   - Set up validation in CI
   - Split before hitting pain threshold

## AI Agent Collaboration

### How AI Agents Used This Spec

**GitHub Copilot Agent**:
1. Read main README for architectural decision
2. Referenced DESIGN.md for implementation details
3. Implemented `FilesystemSpecsSource` matching interface design
4. Added caching logic based on performance requirements
5. Created tests matching success criteria

**Challenges**:
- **Token count**: 3,847 tokens in README (approaching limit)
- **Context switching**: Had to reference both README + DESIGN.md
- **Solution**: Agent read README first, then DESIGN.md for details

**Success factors**:
- Clear architecture diagram (visual = fast comprehension)
- Explicit interface definitions (SpecsSource)
- Performance targets (< 100ms reads)
- Phase 1/2 split made scope clear

**Agent autonomy**: 75% - Agent implemented filesystem mode with guidance. Human provided course corrections on caching strategy and scope decisions.

### Spec Quality Challenges

What made this spec harder for AI agents:

1. **High token count** - Approaching Context Economy threshold
2. **Multi-file structure** - README + DESIGN.md requires navigation
3. **Architectural decisions** - Requires understanding trade-offs, not just implementation
4. **Evolving scope** - Phase 2 deferred mid-implementation

**Mitigation strategies**:
- Split into sub-specs early (not late)
- Use diagrams for quick comprehension
- Make phase boundaries explicit upfront
- Link between README and sub-specs clearly

### Human-AI Division of Labor

**Human role**:
- Architectural decision-making (dual-mode vs single-mode)
- Scope management (defer Phase 2)
- Trade-off analysis (complexity vs flexibility)
- Performance validation in production

**AI role**:
- Implementation of filesystem source
- Caching logic implementation
- Test case generation
- Documentation updates

**Result**: Architectural complexity required more human guidance than simple features (spec 071), but AI still implemented 75% of code.

---

## Try It Yourself

Want to tackle a complex architectural decision?

1. **Start with the decision, not the implementation** - Document "why" first
2. **Use diagrams** - Visual comprehension is 10x faster
3. **Split at 3,500 tokens** - Don't wait until 5,000
4. **Defer complexity** - Ship Phase 1, learn, then build Phase 2
5. **Monitor token counts** - Run `lean-spec tokens <spec>` frequently

**Template**: Use [spec 082](https://web.lean-spec.dev/specs/082-web-realtime-sync-architecture) as a template for architectural decisions that need phased implementation.

**Key Question**: Can you ship a simpler version that validates the architecture? Start there.
