# Why LeanSpec?

**LeanSpec is a lightweight SDD (Spec-Driven Development) framework optimized for velocity through human-AI alignment.**

**Core strengths:**
- **Lightweight** - Minimal setup, no heavy dependencies  
- **Simplicity** - Start with one file, grow as needed
- **Agility** - Direct editing, no multi-step workflows
- **Adaptivity** - Works with any editor, AI tool, team size, or organizational culture
- **Comprehensive tooling** - CLI, MCP server, validation

**Why this drives development velocity:** Our first principles (Context Economy, Signal-to-Noise, Intent Over Implementation) lead to high human-AI alignment, low context rot, and low cognitive load. **Result: Better quality ‚Üí Less rework ‚Üí Higher velocity.**

## Quick Comparison

| Feature | LeanSpec | Spec Kit | OpenSpec | Kiro | PM Tools | Vibe Coding |
|---------|----------|----------|----------|------|----------|-------------|
| **Type** | SDD Framework | SDD Framework | SDD Framework | AI IDE + SDD | Project Mgmt | No Structure |
| **Spec Structure** | ‚úÖ Flexible | ‚ö†Ô∏è Rigid format | ‚ö†Ô∏è Rigid templates | ‚úÖ Built-in | ‚ùå Task-based | ‚ùå None |
| **AI Optimization** | ‚úÖ Controlled length | ‚ö†Ô∏è Longer context | ‚ö†Ô∏è Long system prompt | ‚úÖ Native | ‚ùå Rich text | ‚úÖ Chat |
| **Workflow** | Flexible | 5-step process | Proposal‚ÜíArchive | Autonomous | Tickets/sprints | Prompt |
| **Access Latency** | ‚úÖ Instant (local) | ‚úÖ Instant (local) | ‚úÖ Instant (local) | ‚úÖ IDE-native | ‚ùå API/MCP config | ‚úÖ Chat |
| **Numbering** | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No | ‚ö†Ô∏è IDE-managed | ‚úÖ Ticket IDs | ‚ùå None |
| **CLI Tools** | ‚úÖ Full-featured | ‚úÖ Slash commands | ‚úÖ Slash commands | ‚úÖ Built-in | ‚ùå Web UI | ‚ùå None |
| **MCP Server** | ‚úÖ Yes | ‚ùå No | ‚ùå No | ‚ö†Ô∏è Varies | ‚ö†Ô∏è Requires config | ‚ùå No |
| **Visual Mode (UI)** | ‚úÖ Yes | ‚ùå CLI only | ‚ùå CLI only | ‚úÖ Built-in | ‚úÖ Web UI | ‚ùå None |
| **Editor** | Any | Any | Any | Locked (Kiro) | Web/any | Any |
| **Cognitive Load** | ‚úÖ Low | ‚ö†Ô∏è Higher | ‚ö†Ô∏è Higher | ‚ö†Ô∏è New IDE | ‚ö†Ô∏è Varies | ‚úÖ Very Low |
| **Adaptivity** | ‚úÖ High | ‚ö†Ô∏è Prescriptive | ‚ö†Ô∏è Prescriptive | ‚ö†Ô∏è IDE-locked | ‚ö†Ô∏è Org-specific | ‚úÖ Very High |
| **Best For** | Teams 1-50+ | Enterprise SDD | Formal proposals | Solo/small | Large orgs | Solo prototyping |

### When to Choose LeanSpec

**‚úÖ Choose LeanSpec when you value:**
- Lightweight setup with no heavy dependencies
- Simple, flexible structure starting from one file
- Direct editing without multi-step workflows  
- Works with any editor or AI tool
- Low latency with local, version-controlled specs
- High velocity through low cognitive load

**üîÑ Choose alternatives when you need:**
- **Enterprise governance**: Spec Kit for prescriptive 5-step process
- **Formal change proposals**: OpenSpec for proposal ‚Üí review ‚Üí archive
- **Integrated AI IDE**: Kiro for all-in-one SDD + autonomous agents
- **Project management**: Jira/Linear for task tracking (use WITH LeanSpec)
- **Maximum speed**: Vibe coding for solo prototypes (no structure)

---

## Detailed Comparisons

### vs. Spec Kit

**[Spec Kit](https://github.com/github/spec-kit)** (by GitHub) provides a structured multi-step workflow: constitution ‚Üí specify ‚Üí plan ‚Üí tasks ‚Üí implement.

**Spec Kit strengths:**
- ‚úÖ Structured governance with constitution and principles
- ‚úÖ Clear multi-step workflow for enterprise teams
- ‚úÖ Native VS Code integration with quick action buttons in Copilot Chat
- ‚úÖ Rich slash command integration
- ‚úÖ Strong focus on quality and testing standards

**Trade-offs:**
- **Rigid spec format** creates cognitive load for human reviewers
- **Longer context** (constitution + spec + plan + tasks) may degrade AI performance
- **Process overhead** with 5 required steps before coding
- **Multiple files** per feature increase navigation complexity
- **Prescriptive structure** less adaptable to different team cultures

**Best for**: Enterprise teams needing structured governance and formal planning phases.

**LeanSpec's advantage**: **Lightweight & adaptable**. Flexible structure (single file or sub-specs as needed), under 2,000 tokens for optimal AI/human performance. Progressive disclosure over prescriptive process. No required workflow‚Äîadapt to your team's culture.

### vs. OpenSpec

**[OpenSpec](https://github.com/Fission-AI/OpenSpec)** treats specs as evolving proposals with change tracking, proposal folders, and diff-based workflows.

**OpenSpec strengths:**
- ‚úÖ Explicit change proposals for team review
- ‚úÖ Clear separation between current state and proposed changes
- ‚úÖ Strong for brownfield projects and cross-spec updates
- ‚úÖ Structured delta format (ADDED/MODIFIED/REMOVED)

**Trade-offs:**
- **No numbering system** - Harder to reference specs in long-term project management
- **Rigid workflow** - Proposal ‚Üí apply ‚Üí archive steps required
- **Rigid templates** - Structured delta format may not fit all use cases
- **Long system prompt** - AGENTS.md &gt;400 lines may cause context rot over time
- **Slash command dependency** - Requires specific prompt files (openspec-xxx.prompt.md)

**Best for**: Teams wanting formal change proposals with review workflows before merging to spec source of truth.

**LeanSpec's advantage**: **Simplicity & agility**. Numbered specs for easy reference. Direct editing with git version control. No proposals, no change folders, no archive step. Flexible templates. Concise AGENTS.md (under 2,000 tokens). Edit specs like code‚Äîcommit, push, done.


### vs. AI IDEs (Kiro)

**[Kiro](https://kiro.dev)** is a full AI IDE with built-in spec-driven development and autonomous agents.

**Kiro strengths:**
- ‚úÖ Integrated spec-driven development
- ‚úÖ Autonomous agents and autopilot modes
- ‚úÖ Built-in context management
- ‚úÖ Seamless AI interaction within editor

**Trade-offs:**
- **IDE lock-in** - Must switch from current editor
- **Subscription cost** - $20-40/month
- **Learning curve** - New editor and workflows
- **Less control** - Opinionated autopilot behavior

**LeanSpec's advantage**: **Adaptivity & flexibility**. Editor-agnostic‚Äîworks with any AI tool (Copilot, Claude, Cursor, Windsurf) and any editor (VS Code, JetBrains, Vim, Emacs). Keep existing workflow and muscle memory.


### vs. Document Collections (RFC/ADR)

Traditional approaches for documenting technical decisions.

**Limitations:**
- No tooling: Manual file management
- Inconsistent structure across teams
- Not AI-optimized (often 1000+ lines)

**LeanSpec's advantage**: RFC/ADR philosophy + modern tooling. CLI/MCP tools, consistent structure, AI-optimized (&lt;2,000 tokens), search and validation.

### vs. Project Management Tools (Jira, Linear)

PM tools excel at task tracking and team coordination.

**Trade-offs for technical specs:**
- Higher latency (API/MCP configuration needed)
- Rich text editors can't fit in AI context windows  
- Not version controlled with code
- Wrong abstraction (tickets vs. technical specs)

**LeanSpec's advantage**: Specs live in your repo‚Äîzero API overhead. Version controlled with code. Use Jira for task tracking, LeanSpec for technical specs.

### vs. Vibe Coding

Fastest way to start‚Äîjust chat with AI, no specs.

**Trade-offs:**
- No team alignment or documentation
- Decisions lost in chat history
- AI may hallucinate without written specs

**LeanSpec's advantage**: Minimal structure for maximum agility. Just enough spec to align team and guide AI without heavy process.


## Philosophy: First Principles Over Process

LeanSpec is built on **5 First Principles** (in priority order):

1. **Context Economy** - Specs must fit in working memory (typically &lt;2,000 tokens)
2. **Signal-to-Noise** - Every word must inform decisions  
3. **Intent Over Implementation** - Capture why, not just how
4. **Bridge the Gap** - Both human and AI must understand
5. **Progressive Disclosure** - Add complexity only when pain is felt

Other tools add features and process upfront. LeanSpec starts minimal and grows only when you feel pain.

üìñ [Deep dive: First Principles ‚Üí](/docs/advanced/first-principles)


## Migration & Realistic Expectations

### Migration from Other Tools

Already using OpenSpec, spec-kit, or ADRs?

```bash
lean-spec migrate ./path/to/specs          # Migrate from any SDD tool
lean-spec migrate ./path/to/specs --with copilot  # AI-assisted migration
lean-spec backfill                         # Backfill metadata from git
```

See [Migration Guide](/docs/guide/migration) for details.

### Realistic About Limits

A [critical assessment by Robert Matsuoka](https://hyperdev.matsuoka.com/p/is-ai-a-bubble-i-didnt-think-so-until) notes AI coding valuations (25-70x ARR vs dot-com peak of 18x) and warns of correction within 18-24 months.

**LeanSpec's positioning:**
- ‚úÖ Free, open-source‚Äînot selling platforms or IDEs
- ‚úÖ Pragmatic about when specs help vs hurt
- ‚úÖ Honest about limits ([Rice's Theorem](https://www.marvinzhang.dev/blog/rices-theorem-why-automated-testing-will-fail) proves complete automation is impossible)
- ‚úÖ Enhances rather than replaces core capabilities

**The theoretical foundation:** Rice's Theorem (1951) proves AI can't algorithmically determine "what you want." Specs provide semantic grounding‚Äîhumans define intent, AI amplifies scale within those constraints.

**Can specs become theater?** Yes, when exhaustive, unread, or static. LeanSpec avoids this through explicit "when NOT to use specs" guidance, 2,000-token target, and focus on intent over implementation.

üìñ [Deep dive: Limits, Trade-offs & What's Realistic ‚Üí](/docs/advanced/limits-and-tradeoffs)
